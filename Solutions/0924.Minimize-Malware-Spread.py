924. Minimize Malware Spread

In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1.

Some nodes initial are initially infected by malware.  Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware.  This spread of malware will continue until no more nodes can be infected in this manner.

Suppose M(initial) is the final number of nodes infected with malware in the entire network, after the spread of malware stops.

We will remove one node from the initial list.  Return the node that if removed, would minimize M(initial).  If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.

Note that if a node was removed from the initial list of infected nodes, it may still be infected later as a result of the malware spread.

 

Example 1:

Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
Output: 0
Example 2:

Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
Output: 0
Example 3:

Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
Output: 1


"""
实际上这道题的本质还是遍历这个无向图，遍历的方法就有 DFS 和 BFS 两种。方法是先尝试去掉一个node，然后看有多少可以感染；
然后尝试去掉另一个node，看看多少可以感染；比较去掉哪一个node能使得感染的最少。
O(M* N^2)
"""
class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        initial.sort()      # sort the initial so that we can return the smaller node if there are multiple answers
        min_infected = len(graph) + 1
        res = 0
        for node in initial:
            infected = self._bfs(graph, initial, node)   # I think it's easier if we change the graph from adjacency matrix to adjacency list
            if infected < min_infected:
                min_infected = infected
                res = node
        return res
                
    def _bfs(self, graph, initial, exclude_node):
        infected = 0
        q = collections.deque()
        visited = set()
        for node in initial:
            if node == exclude_node:
                continue
            q.append(node)
            visited.add(node)
            
        while q:
            curr = q.popleft()
            infected += 1
            for i in range(len(graph)):
                if graph[i][curr] == 1:
                    if i not in visited:
                        q.append(i)
                        visited.add(i)     
                        
        return infected
        
"""
solutin 2: dfs 这个题的dfs没有bfs那么简洁
"""


"""
solution 3: union find.
step 1: connect the original graph, so that we have multiple connected components and we keep track of size of each component.
step 2: traverse the initial infected list, and check which node in the list has the largest connected component size.
The one in the largest connected component sizee can infect the most nodes, so we should delete it.
"""
class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        initial.sort()  # sort the initial so that we can return the smaller node if there are multiple answers
        
        uf = UnionFind(graph)
        
        # 这个算法解决本体有一个弊端需要规避，那就是如果initial中有两个node在max_size component中，
        # 那么删掉其中一个并没有任何鸟用，所以我们先找到这些需要规避的node吧
        exclude = set()
        for i in range(len(initial)-1):
            for j in range(i+1, len(initial)):
                if uf.connected(initial[i], initial[j]):
                    exclude.add(initial[i])
                    exclude.add(initial[j])
                
        # 接下来就是我们的main algorithm: traverse the initial infected list, 
        # and check which node in the list has the largest connected component size.
        # The one in the largest connected component sizee can infect the most nodes, so we should delete it.
        max_sz = -1
        res = initial[0]
        for node in initial:
            if node in exclude:
                continue
            sz = uf.size[uf.find(node)]     # 注意这里千万要去query uf.find[node]的size，而不是node的
            if sz > max_sz:
                max_sz = sz
                res = node
        return res
    
    
class UnionFind:
    
    def __init__(self, graph):
        self.father = collections.defaultdict(int)
        self.size = collections.defaultdict(int)    # store the number of nodes in each disjoint components
        
        for i in range(len(graph)):
            self.add(i)
            
        for i in range(len(graph)):
            for j in range(i + 1, len(graph)):     # 只需要取整个matrix的一半就可以了，另一半是的信息是一样的
                if graph[i][j] == 1:
                    self.union(i, j)
                    
    def add(self, x):
        self.father[x] = x
        self.size[x] = 1      # *****这里不要忘了initialize size
    
    def find(self, x):
        if self.father[x] == x:
            return x
        self.father[x] = self.find(self.father[x])
        return self.father[x]
    
    def connected(self, a, b):
        return self.find(a) == self.find(b)
    
    def union(self, a, b):
        root_a, root_b = self.find(a), self.find(b)
        if root_a != root_b:
            self.father[root_a] = root_b
            self.size[root_b] += self.size[root_a]  # 注意这里a, b的顺序必须与前面保持一致
